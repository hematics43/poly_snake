<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>🐍-Snake-🐍</title>
<style>
#beeLink {
  position: fixed;
  top: 15px;
  right: 15px;
  padding: 8px 12px;
  background: #111;
  color: #0ff;
  border: 2px solid #0ff;
  border-radius: 10px;
  text-decoration: none;
  font-weight: bold;
  text-shadow: 0 0 5px #0ff, 0 0 10px #0ff;
  box-shadow: 0 0 15px #0ff, 0 0 30px #0ff inset;
  transition: all 0.3s ease;
  z-index: 1000;
}
#beeLink:hover {
  color: #ff0;
  text-shadow: 0 0 10px #ff0, 0 0 20px #ff0;
  box-shadow: 0 0 20px #ff0, 0 0 40px #ff0 inset;
}

#beeLink:hover {
  color: rgb(89, 3, 3);
  text-shadow: 0 0 10px #ff0, 0 0 20px #ff0;
  box-shadow: 0 0 20px #ff0, 0 0 40px #ff0 inset;
}

*{margin:0;padding:0;box-sizing:border-box;}
body{
  display:flex;
  flex-direction:column;
  justify-content:flex-start;
  align-items:center;
  height:100vh;
  background:#0f0f0f;
  font-family:'Courier New', monospace;
  overflow:hidden;
}
h1{
  margin-top:10px;
  color:#0ff;
  text-shadow:0 0 5px #0ff,0 0 10px #0ff,0 0 20px #0ff,0 0 40px #0ff;
  font-size:2rem;
  text-align:center;
}
#controls{
  display:flex;
  gap:15px;
  align-items:center;
  justify-content:center;
  margin-top:5px;
  flex-wrap:wrap;
}
label{
  color:#0ff;
  text-shadow:0 0 5px #0ff,0 0 10px #0ff;
}
input[type=range]{
  width:120px;
  height:5px;
  background:#0ff;
  border-radius:5px;
  outline:none;
  box-shadow:0 0 10px #0ff;
}
button{
  padding:8px 15px;
  border:2px solid #0ff;
  border-radius:10px;
  color:#0ff;
  background:#111;
  cursor:pointer;
  text-shadow:0 0 5px #0ff;
  box-shadow:0 0 10px #0ff;
  font-size:0.9rem;
}
#score{
  color:#0ff;
  font-size:1.5rem;
  text-shadow:0 0 5px #0ff,0 0 10px #0ff,0 0 20px #0ff;
  margin-top:5px;
}
canvas{
  background:#111;
  border:2px solid #0ff;
  box-shadow:0 0 20px #0ff,0 0 40px #0ff inset;
  border-radius:20px;
  touch-action:none;
  width:90vmin;
  height:90vmin;
  margin-top:10px;
}
/* Arrow buttons below */
#arrowControls{
  display:flex;
  flex-direction:column;
  align-items:center;
  margin-top:15px;
  gap:10px;
}
.row{
  display:flex;
  gap:10px;
}
.arrowBtn{
  width:60px;
  height:60px;
  background:#111;
  border:2px solid #0ff;
  border-radius:10px;
  color:#0ff;
  font-size:2rem;
  text-align:center;
  line-height:60px;
  box-shadow:0 0 10px #0ff;
}
</style>
</head>
<body><h1>🐍 🔥 😎</h1>
<div id="controls">
  <label>Speed:
    <input type="range" id="speedRange" min="1" max="10" value="4">
  </label>
  <label>Thickness:
    <input type="range" id="thicknessRange" min="0.3" max="1.5" step="0.1" value="1">
  </label>
  <button id="shapeBtn">Shape: Square</button>
  <button id="modeBtn">Mode: Emoji</button>
</div>
<div id="score">Score: 0</div>
<canvas id="gameCanvas"></canvas>

<div id="arrowControls">
  <div class="row">
    <button class="arrowBtn" data-dir="up">↑</button>
  </div>
  <div class="row">
    <button class="arrowBtn" data-dir="left">←</button>
    <button class="arrowBtn" data-dir="down">↓</button>
    <button class="arrowBtn" data-dir="right">→</button>
  </div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const speedRange = document.getElementById('speedRange');
const thicknessRange = document.getElementById('thicknessRange');
const shapeBtn = document.getElementById('shapeBtn');
const modeBtn = document.getElementById('modeBtn');
const arrowBtns = document.querySelectorAll('.arrowBtn');

let gameRunning = true;
let shapes = ['square','circle','rounded','triangle','diamond','hexagon','star','heart'];
let shapeIndex = 0;
let snakeShape = shapes[shapeIndex];
let mode = 'emoji'; // emoji or shape
let speed = parseInt(speedRange.value);
let snakeThickness = parseFloat(thicknessRange.value);
let count = 0;
let grid = 20;
let cols, rows;
let snake, apple, score;

let faceEmojis = [
  '😀', '😁', '😂', '🤣', '😃', '😄', '😅', '😆', '😉', '😊', '😋', '😎', '😍', '😘', '😗', '😙', '😚',
  '☺', '🙂', '🤗', '🤔', '😐', '😑', '😶', '🙄', '😏', '😣', '😥', '😮', '🤐', '😯', '😪', '😫', '😴',
  '😌', '🤓', '😛', '😜', '😝', '🤤', '😒', '😓', '😔', '😕', '🙃', '🤑', '😲', '☹', '🙁', '😖', '😞',
  '😟', '😤', '😥', '😦', '😧', '😨', '😩', '😪', '😫', '😬', '😭', '😮', '😯', '😰', '😱', '😲', '😳',
  '😴', '😵', '😶', '😷', '😸', '😹', '😺', '😻', '😼', '😽', '😾', '😿', '🙀', '🙈', '🙉', '🙊', '🙋',
  '🙌', '🙍', '🙎', '🙏'
];

const colors = [
  '#0ff','#f0f','#ff0','#f80','#0f0','#08f','#f08','#ff1493','#00fa9a','#7fff00',
  '#1e90ff','#ff4500','#ffd700','#00ced1','#ff69b4','#adff2f','#ffa500','#7cfc00','#ff6347',
  '#40e0d0','#ff00ff','#00ff7f','#ff1493','#ff7f50','#7b68ee','#00bfff','#32cd32','#ff8c00','#ff69b4',
  '#00ff00','#ff4500','#7fff00','#ff00ff','#1e90ff','#ff6347','#ffd700','#00ced1','#ff1493','#adff2f',
  '#ff7f50','#00fa9a','#7cfc00','#ff69b4','#40e0d0','#ff00ff','#ff6347','#32cd32','#ff8c00','#7b68ee',
  '#00bfff','#ff4500','#00ff7f','#ff1493','#ff7f50','#7fff00','#ff69b4','#00ced1','#ffd700','#1e90ff',
  '#adff2f','#ff4500','#00fa9a','#ff00ff','#32cd32','#7cfc00','#ff6347','#40e0d0','#ff1493','#ff8c00',
  '#7b68ee','#00bfff','#ff69b4','#ff7f50','#00ff7f','#ff4500','#ff00ff','#ff1493','#ffd700','#00ced1',
  '#7fff00','#adff2f','#ff6347','#00fa9a','#ff8c00','#32cd32','#1e90ff','#40e0d0','#7cfc00','#ff69b4',
  '#ff1493','#00bfff','#ff7f50','#00ff7f','#7b68ee','#ff4500','#ff00ff','#ffd700','#adff2f','#00ced1'
];

function resizeCanvas(){
  canvas.width = canvas.clientWidth;
  canvas.height = canvas.clientHeight;
  cols = Math.floor(canvas.width/grid);
  rows = Math.floor(canvas.height/grid);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

function resetGame(){
  snake = {
    x: Math.floor(cols/2)*grid,
    y: Math.floor(rows/2)*grid,
    dx: grid,
    dy: 0,
    cells: [],
    maxCells:4
  };
  apple = {
    x: getRandomInt(0, cols)*grid,
    y: getRandomInt(0, rows)*grid
  };
  score = 0;
  scoreEl.textContent = "Score: 0";
  speed = parseInt(speedRange.value);
  snakeThickness = parseFloat(thicknessRange.value);
}

function getRandomInt(min,max){return Math.floor(Math.random()*(max-min))+min;}

function drawCell(x, y, color){
  ctx.fillStyle = color;
  ctx.shadowColor = color;
  ctx.shadowBlur = 20;
  let size = grid * snakeThickness - 2;
  let offset = (grid - size)/2;

  switch(snakeShape){
    case 'circle':
      ctx.beginPath();
      ctx.arc(x + grid/2, y + grid/2, size/2, 0, Math.PI*2);
      ctx.fill();
      break;
    case 'rounded':
      ctx.fillRect(x + offset, y + offset, size, size);
      ctx.beginPath();
      ctx.arc(x + grid/2, y + grid/2, size/4, 0, Math.PI*2);
      ctx.fill();
      break;
    case 'triangle':
      ctx.beginPath();
      ctx.moveTo(x + grid/2, y + offset);
      ctx.lineTo(x + grid - offset, y + grid - offset);
      ctx.lineTo(x + offset, y + grid - offset);
      ctx.closePath();
      ctx.fill();
      break;
    case 'diamond':
      ctx.beginPath();
      ctx.moveTo(x + grid/2, y + offset);
      ctx.lineTo(x + grid - offset, y + grid/2);
      ctx.lineTo(x + grid/2, y + grid - offset);
      ctx.lineTo(x + offset, y + grid/2);
      ctx.closePath();
      ctx.fill();
      break;
    case 'hexagon':
      let cx = x + grid/2;
      let cy = y + grid/2;
      let r = size/2;
      ctx.beginPath();
      for(let i=0;i<6;i++){
        let angle = Math.PI/3*i;
        ctx.lineTo(cx + r*Math.cos(angle), cy + r*Math.sin(angle));
      }
      ctx.closePath();
      ctx.fill();
      break;
    case 'star':
      let sx = x + grid/2;
      let sy = y + grid/2;
      let outerR = size/2;
      let innerR = outerR/2.5;
      ctx.beginPath();
      for(let i=0;i<5;i++){
        let angle = i * 2 * Math.PI /5 - Math.PI/2;
        ctx.lineTo(sx + outerR*Math.cos(angle), sy + outerR*Math.sin(angle));
        angle += Math.PI/5;
        ctx.lineTo(sx + innerR*Math.cos(angle), sy + innerR*Math.sin(angle));
      }
      ctx.closePath();
      ctx.fill();
      break;
    case 'heart':
      let hx = x + grid/2;
      let hy = y + grid/2;
      ctx.beginPath();
      ctx.moveTo(hx, hy + size/4);
      ctx.bezierCurveTo(hx + size/2, hy - size/4, hx + size/4, hy - size/2, hx, hy - size/6);
      ctx.bezierCurveTo(hx - size/4, hy - size/2, hx - size/2, hy - size/4, hx, hy + size/4);
      ctx.closePath();
      ctx.fill();
      break;
    default:
      ctx.fillRect(x + offset, y + offset, size, size);
  }
}

function drawEmoji(emoji,x,y){
  ctx.font = grid * snakeThickness + 'px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.shadowColor = '#0ff';
  ctx.shadowBlur = 15;
  ctx.fillText(emoji, x + grid/2, y + grid/2);
}

function loop(){
  if(!gameRunning) return;
  requestAnimationFrame(loop);
  if(++count<speed) return;
  count=0;
  ctx.clearRect(0,0,canvas.width,canvas.height);

  snake.x += snake.dx;
  snake.y += snake.dy;

  if(snake.x<0 || snake.x>=canvas.width || snake.y<0 || snake.y>=canvas.height){
    resetGame();
    return;
  }

  snake.cells.unshift({x:snake.x,y:snake.y});
  if(snake.cells.length>snake.maxCells) snake.cells.pop();

  // Draw apple/food
  if(mode==='emoji'){
    drawEmoji(faceEmojis[score%faceEmojis.length], apple.x, apple.y);
  } else {
    const foodColor = colors[Math.floor(Math.random()*colors.length)];
    drawCell(apple.x, apple.y, foodColor);
  }

  snake.cells.forEach((cell,index)=>{
    if(mode==='emoji'){
      const emoji = faceEmojis[index % faceEmojis.length];
      drawEmoji(emoji, cell.x, cell.y);
    } else {
      const color = colors[index % colors.length];
      drawCell(cell.x, cell.y, color);
    }

    if(cell.x===apple.x && cell.y===apple.y){
      snake.maxCells++;
      score++;
      scoreEl.textContent="Score: "+score;
      apple.x = getRandomInt(0,cols)*grid;
      apple.y = getRandomInt(0,rows)*grid;
      speed = Math.max(1, speed - 0.1);
    }

    for(let i=index+1;i<snake.cells.length;i++){
      if(cell.x===snake.cells[i].x && cell.y===snake.cells[i].y){
        resetGame();
      }
    }
  });
}

// Keyboard
document.addEventListener('keydown',e=>{
  if(e.key==='ArrowLeft' && snake.dx===0){snake.dx=-grid; snake.dy=0;}
  else if(e.key==='ArrowUp' && snake.dy===0){snake.dx=0; snake.dy=-grid;}
  else if(e.key==='ArrowRight' && snake.dx===0){snake.dx=grid; snake.dy=0;}
  else if(e.key==='ArrowDown' && snake.dy===0){snake.dx=0; snake.dy=grid;}
});

// Mobile arrows
arrowBtns.forEach(btn=>{
  btn.addEventListener('touchstart',()=>{
    const dir = btn.dataset.dir;
    if(dir==='up' && snake.dy===0){snake.dx=0; snake.dy=-grid;}
    if(dir==='down' && snake.dy===0){snake.dx=0; snake.dy=grid;}
    if(dir==='left' && snake.dx===0){snake.dx=-grid; snake.dy=0;}
    if(dir==='right' && snake.dx===0){snake.dx=grid; snake.dy=0;}
  });
});

// Swipe
let touchStartX = null;
let touchStartY = null;
canvas.addEventListener('touchstart',e=>{
  const touch = e.touches[0];
  touchStartX = touch.clientX;
  touchStartY = touch.clientY;
});
canvas.addEventListener('touchmove',e=>{
  const touch = e.touches[0];
  const dx = touch.clientX-touchStartX;
  const dy = touch.clientY-touchStartY;
  if(Math.abs(dx)>Math.abs(dy)){
    if(dx>0 && snake.dx===0){snake.dx=grid; snake.dy=0;}
    else if(dx<0 && snake.dx===0){snake.dx=-grid; snake.dy=0;}
  }else{
    if(dy>0 && snake.dy===0){snake.dx=0; snake.dy=grid;}
    else if(dy<0 && snake.dy===0){snake.dx=0; snake.dy=-grid;}
  }
  touchStartX=null;
  touchStartY=null;
});

// UI
speedRange.addEventListener('input',()=>{speed=parseInt(speedRange.value);});
thicknessRange.addEventListener('input',()=>{snakeThickness=parseFloat(thicknessRange.value);});
shapeBtn.addEventListener('click',()=>{
  shapeIndex = (shapeIndex+1)%shapes.length;
  snakeShape = shapes[shapeIndex];
  shapeBtn.textContent = 'Shape: ' + snakeShape.charAt(0).toUpperCase()+snakeShape.slice(1);
});
modeBtn.addEventListener('click',()=>{
  mode = mode==='emoji'?'shape':'emoji';
  modeBtn.textContent = 'Mode: ' + (mode==='emoji'?'Emoji':'Shapes');
});
resetGame();
requestAnimationFrame(loop);
</script>
<a href="https://hematics43.github.io/beecodeworld/" target="_blank" id="beeLink">More links</a>
</body>
</html>
